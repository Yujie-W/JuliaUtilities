<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ConstrainedRootSolvers · JuliaUtilities</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="JuliaUtilities logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">JuliaUtilities</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>ConstrainedRootSolvers</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Numerical-methods"><span>Numerical methods</span></a></li><li><a class="tocitem" href="#Method-options"><span>Method options</span></a></li><li><a class="tocitem" href="#Tolerance-options"><span>Tolerance options</span></a></li></ul></li><li><a class="tocitem" href="../NetcdfIO/">NetcdfIO</a></li><li><a class="tocitem" href="../PkgUtility/">PkgUtility</a></li><li><a class="tocitem" href="../PlotPlants/">PlotPlants</a></li><li><a class="tocitem" href="../TextIO/">TextIO</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>ConstrainedRootSolvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ConstrainedRootSolvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Yujie-W/JuliaUtilities/blob/main/docs/src/ConstrainedRootSolvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><pre><code class="language-julia hljs">using ConstrainedRootSolvers

_f_2_solve(x) = exp(-1 * (x/2)^5) - 0.5;

sol = find_zero(_f_2_solve, BisectionMethod{Float64}(x_min=0, x_max=10), SolutionTolerance{Float64}(0.001))
sol = find_zero(_f_2_solve, NewtonBisectionMethod{Float64}(0.0, 10.0, 2.0), ResidualTolerance{Float64}(0.001))
sol = find_zero(_f_2_solve, NewtonRaphsonMethod{Float64}(2.0), ResidualTolerance{Float64}(0.001))</code></pre><h2 id="Numerical-methods"><a class="docs-heading-anchor" href="#Numerical-methods">Numerical methods</a><a id="Numerical-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-methods" title="Permalink"></a></h2><h3 id="Find-zero"><a class="docs-heading-anchor" href="#Find-zero">Find zero</a><a id="Find-zero-1"></a><a class="docs-heading-anchor-permalink" href="#Find-zero" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.find_zero" href="#ConstrainedRootSolvers.find_zero"><code>ConstrainedRootSolvers.find_zero</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Function to find the first root that gives a target function result of zero. If     the root does not exist, the function returns the point where the target     function is most close to zero.</p><pre><code class="language-julia hljs">find_zero(f, ms, tol; stepping)</code></pre><p>defined at <a href="https://github.com/Yujie-W/JuliaUtilities/tree/017271df0147a581d13485e2afb8d02684580703//packages/ConstrainedRootSolvers.jl/src/find_zero.jl#L40"><code>/home/runner/work/JuliaUtilities/JuliaUtilities/packages/ConstrainedRootSolvers.jl/src/find_zero.jl:40</code></a>.</p><pre><code class="language-julia hljs">find_zero(f, ms, tol; stepping)</code></pre><p>defined at <a href="https://github.com/Yujie-W/JuliaUtilities/tree/017271df0147a581d13485e2afb8d02684580703//packages/ConstrainedRootSolvers.jl/src/find_zero.jl#L144"><code>/home/runner/work/JuliaUtilities/JuliaUtilities/packages/ConstrainedRootSolvers.jl/src/find_zero.jl:144</code></a>.</p><pre><code class="language-julia hljs">find_zero(f, ms, tol; stepping)</code></pre><p>defined at <a href="https://github.com/Yujie-W/JuliaUtilities/tree/017271df0147a581d13485e2afb8d02684580703//packages/ConstrainedRootSolvers.jl/src/find_zero.jl#L258"><code>/home/runner/work/JuliaUtilities/JuliaUtilities/packages/ConstrainedRootSolvers.jl/src/find_zero.jl:258</code></a>.</p><pre><code class="language-julia hljs">find_zero(f, ms, tol; stepping)</code></pre><p>defined at <a href="https://github.com/Yujie-W/JuliaUtilities/tree/017271df0147a581d13485e2afb8d02684580703//packages/ConstrainedRootSolvers.jl/src/find_zero.jl#L322"><code>/home/runner/work/JuliaUtilities/JuliaUtilities/packages/ConstrainedRootSolvers.jl/src/find_zero.jl:322</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/find_zero.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.find_zero-Union{Tuple{FT}, Tuple{Function, ConstrainedRootSolvers.BisectionMethod{FT}, Union{ConstrainedRootSolvers.ResidualTolerance{FT}, ConstrainedRootSolvers.SolutionTolerance{FT}}}} where FT&lt;:AbstractFloat" href="#ConstrainedRootSolvers.find_zero-Union{Tuple{FT}, Tuple{Function, ConstrainedRootSolvers.BisectionMethod{FT}, Union{ConstrainedRootSolvers.ResidualTolerance{FT}, ConstrainedRootSolvers.SolutionTolerance{FT}}}} where FT&lt;:AbstractFloat"><code>ConstrainedRootSolvers.find_zero</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This method uses <a href="#ConstrainedRootSolvers.BisectionMethod"><code>BisectionMethod</code></a> method:</p><pre><code class="nohighlight hljs">find_zero(f::Function,
          ms::BisectionMethod{FT},
          tol::Union{ResidualTolerance{FT}, SolutionTolerance{FT}};
          stepping::Bool = false
) where {FT&lt;:AbstractFloat}</code></pre><p>Returns the solution where target function is zero, given</p><ul><li><code>f</code> Function to solve</li><li><code>ms</code> <a href="#ConstrainedRootSolvers.BisectionMethod"><code>BisectionMethod</code></a> type method struct</li><li><code>tol</code> <a href="#ConstrainedRootSolvers.ResidualTolerance"><code>ResidualTolerance</code></a> or <a href="#ConstrainedRootSolvers.SolutionTolerance"><code>SolutionTolerance</code></a> type   tolerance struct</li><li><code>stepping</code> Optional. If true, save the optimization steps to the history   field in method struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/find_zero.jl#L19-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.find_zero-Union{Tuple{FT}, Tuple{Function, ConstrainedRootSolvers.NewtonBisectionMethod{FT}, Union{ConstrainedRootSolvers.ResidualTolerance{FT}, ConstrainedRootSolvers.SolutionTolerance{FT}}}} where FT&lt;:AbstractFloat" href="#ConstrainedRootSolvers.find_zero-Union{Tuple{FT}, Tuple{Function, ConstrainedRootSolvers.NewtonBisectionMethod{FT}, Union{ConstrainedRootSolvers.ResidualTolerance{FT}, ConstrainedRootSolvers.SolutionTolerance{FT}}}} where FT&lt;:AbstractFloat"><code>ConstrainedRootSolvers.find_zero</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This method uses <a href="#ConstrainedRootSolvers.NewtonBisectionMethod"><code>NewtonBisectionMethod</code></a> method:</p><pre><code class="nohighlight hljs">find_zero(f::Function,
          ms::NewtonBisectionMethod{FT},
          tol::Union{ResidualTolerance{FT}, SolutionTolerance{FT}};
          stepping::Bool = false
) where {FT&lt;:AbstractFloat}</code></pre><p>Returns the solution where target function is zero, given</p><ul><li><code>f</code> Function to solve</li><li><code>ms</code> <a href="#ConstrainedRootSolvers.NewtonBisectionMethod"><code>NewtonBisectionMethod</code></a> type method struct</li><li><code>tol</code> <a href="#ConstrainedRootSolvers.ResidualTolerance"><code>ResidualTolerance</code></a> or <a href="#ConstrainedRootSolvers.SolutionTolerance"><code>SolutionTolerance</code></a> type   tolerance struct</li><li><code>stepping</code> Optional. If true, save the optimization steps to the history   field in method struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/find_zero.jl#L123-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.find_zero-Union{Tuple{FT}, Tuple{Function, ConstrainedRootSolvers.NewtonRaphsonMethod{FT}, Union{ConstrainedRootSolvers.ResidualTolerance{FT}, ConstrainedRootSolvers.SolutionTolerance{FT}}}} where FT&lt;:AbstractFloat" href="#ConstrainedRootSolvers.find_zero-Union{Tuple{FT}, Tuple{Function, ConstrainedRootSolvers.NewtonRaphsonMethod{FT}, Union{ConstrainedRootSolvers.ResidualTolerance{FT}, ConstrainedRootSolvers.SolutionTolerance{FT}}}} where FT&lt;:AbstractFloat"><code>ConstrainedRootSolvers.find_zero</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This method uses <a href="#ConstrainedRootSolvers.NewtonRaphsonMethod"><code>NewtonRaphsonMethod</code></a> method:</p><pre><code class="nohighlight hljs">find_zero(f::Function,
          ms::NewtonRaphsonMethod{FT},
          tol::Union{ResidualTolerance{FT}, SolutionTolerance{FT}};
          stepping::Bool = false
) where {FT&lt;:AbstractFloat}</code></pre><p>Returns the solution where target function is zero, given</p><ul><li><code>f</code> Function to solve</li><li><code>ms</code> <a href="#ConstrainedRootSolvers.NewtonRaphsonMethod"><code>NewtonRaphsonMethod</code></a> type method struct</li><li><code>tol</code> <a href="#ConstrainedRootSolvers.ResidualTolerance"><code>ResidualTolerance</code></a> or <a href="#ConstrainedRootSolvers.SolutionTolerance"><code>SolutionTolerance</code></a> type   tolerance struct</li><li><code>stepping</code> Optional. If true, save the optimization steps to the history   field in method struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/find_zero.jl#L237-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.find_zero-Union{Tuple{FT}, Tuple{Function, ConstrainedRootSolvers.ReduceStepMethod{FT}, Union{ConstrainedRootSolvers.ResidualTolerance{FT}, ConstrainedRootSolvers.SolutionTolerance{FT}}}} where FT&lt;:AbstractFloat" href="#ConstrainedRootSolvers.find_zero-Union{Tuple{FT}, Tuple{Function, ConstrainedRootSolvers.ReduceStepMethod{FT}, Union{ConstrainedRootSolvers.ResidualTolerance{FT}, ConstrainedRootSolvers.SolutionTolerance{FT}}}} where FT&lt;:AbstractFloat"><code>ConstrainedRootSolvers.find_zero</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This method uses <a href="#ConstrainedRootSolvers.ReduceStepMethod"><code>ReduceStepMethod</code></a> method:</p><pre><code class="nohighlight hljs">find_zero(f::Function,
          ms::ReduceStepMethod{FT},
          tol::Union{ResidualTolerance{FT}, SolutionTolerance{FT}};
          stepping::Bool = false
) where {FT&lt;:AbstractFloat}</code></pre><p>Returns the solution where target function is zero, given</p><ul><li><code>f</code> Function to solve</li><li><code>ms</code> <a href="#ConstrainedRootSolvers.ReduceStepMethod"><code>ReduceStepMethod</code></a> type method struct</li><li><code>tol</code> <a href="#ConstrainedRootSolvers.ResidualTolerance"><code>ResidualTolerance</code></a> or <a href="#ConstrainedRootSolvers.SolutionTolerance"><code>SolutionTolerance</code></a> type   tolerance struct</li><li><code>stepping</code> Optional. If true, save the optimization steps to the history   field in method struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/find_zero.jl#L301-L317">source</a></section></article><h3 id="Find-peak"><a class="docs-heading-anchor" href="#Find-peak">Find peak</a><a id="Find-peak-1"></a><a class="docs-heading-anchor-permalink" href="#Find-peak" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.find_peak" href="#ConstrainedRootSolvers.find_peak"><code>ConstrainedRootSolvers.find_peak</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Function to find the first root that gives a target function result of maximum.     Note that to compute the lowest value, use -f to make it a peak.</p><pre><code class="language-julia hljs">find_peak(f, ms, tol; stepping)</code></pre><p>defined at <a href="https://github.com/Yujie-W/JuliaUtilities/tree/017271df0147a581d13485e2afb8d02684580703//packages/ConstrainedRootSolvers.jl/src/find_peak.jl#L144"><code>/home/runner/work/JuliaUtilities/JuliaUtilities/packages/ConstrainedRootSolvers.jl/src/find_peak.jl:144</code></a>.</p><pre><code class="language-julia hljs">find_peak(f, ms, tol; stepping)</code></pre><p>defined at <a href="https://github.com/Yujie-W/JuliaUtilities/tree/017271df0147a581d13485e2afb8d02684580703//packages/ConstrainedRootSolvers.jl/src/find_peak.jl#L197"><code>/home/runner/work/JuliaUtilities/JuliaUtilities/packages/ConstrainedRootSolvers.jl/src/find_peak.jl:197</code></a>.</p><pre><code class="language-julia hljs">find_peak(f, ms, tol)</code></pre><p>defined at <a href="https://github.com/Yujie-W/JuliaUtilities/tree/017271df0147a581d13485e2afb8d02684580703//packages/ConstrainedRootSolvers.jl/src/findpeak/neldermead.jl#L6"><code>/home/runner/work/JuliaUtilities/JuliaUtilities/packages/ConstrainedRootSolvers.jl/src/findpeak/neldermead.jl:6</code></a>.</p><pre><code class="language-julia hljs">find_peak(f, ms, tol)</code></pre><p>defined at <a href="https://github.com/Yujie-W/JuliaUtilities/tree/017271df0147a581d13485e2afb8d02684580703//packages/ConstrainedRootSolvers.jl/src/findpeak/reducestep.jl#L6"><code>/home/runner/work/JuliaUtilities/JuliaUtilities/packages/ConstrainedRootSolvers.jl/src/findpeak/reducestep.jl:6</code></a>.</p><pre><code class="language-julia hljs">find_peak(f, ms, tol)</code></pre><p>defined at <a href="https://github.com/Yujie-W/JuliaUtilities/tree/017271df0147a581d13485e2afb8d02684580703//packages/ConstrainedRootSolvers.jl/src/findpeak/reducestepND.jl#L6"><code>/home/runner/work/JuliaUtilities/JuliaUtilities/packages/ConstrainedRootSolvers.jl/src/findpeak/reducestepND.jl:6</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/find_peak.jl#L108-L113">source</a></section></article><h2 id="Method-options"><a class="docs-heading-anchor" href="#Method-options">Method options</a><a id="Method-options-1"></a><a class="docs-heading-anchor-permalink" href="#Method-options" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.AbstractCRSMethod" href="#ConstrainedRootSolvers.AbstractCRSMethod"><code>ConstrainedRootSolvers.AbstractCRSMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type of the ConstrainedRootSolvers methods</p><pre><code class="language-julia hljs">abstract type AbstractCRSMethod{FT&lt;:AbstractFloat}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/method.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.BisectionMethod" href="#ConstrainedRootSolvers.BisectionMethod"><code>ConstrainedRootSolvers.BisectionMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Bisection method for 1D root solvers</p><pre><code class="language-julia hljs">mutable struct BisectionMethod{FT&lt;:AbstractFloat} &lt;: ConstrainedRootSolvers.AbstractCRSMethod{FT&lt;:AbstractFloat}</code></pre><p><strong>Fields</strong></p><ul><li><code>x_min::AbstractFloat</code></li></ul><p>: lower bound</p><ul><li><code>x_max::AbstractFloat</code></li></ul><p>: upper bound</p><ul><li><code>xy::Matrix{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: matrix that stores x and y, used in find_peak</p><ul><li><code>history::Vector</code></li></ul><p>: history of all simulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/method.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.NelderMeadMethod" href="#ConstrainedRootSolvers.NelderMeadMethod"><code>ConstrainedRootSolvers.NelderMeadMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nelder-Mead method for 2D and above solvers</p><pre><code class="language-julia hljs">mutable struct NelderMeadMethod{FT&lt;:AbstractFloat} &lt;: ConstrainedRootSolvers.AbstractCRSMethod{FT&lt;:AbstractFloat}</code></pre><p><strong>Fields</strong></p><ul><li><code>N::Int64</code></li></ul><p>: Number of parameters to optimize</p><ul><li><code>x_inis::Vector{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: Initial values</p><ul><li><code>simplex::Array{Vector{FT}, 1} where FT&lt;:AbstractFloat</code></li></ul><p>: Simplex vector of vector with dimension (N+1) * (N+1)</p><ul><li><code>cen_x::Vector{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: Centroid</p><ul><li><code>ref_x::Vector{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: Reflection</p><ul><li><code>exp_x::Vector{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: Expansion</p><ul><li><code>con_x::Vector{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: Contraction</p><ul><li><code>history::Array{Vector{FT}, 1} where FT&lt;:AbstractFloat</code></li></ul><p>: history of all simulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/method.jl#L44-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.NewtonBisectionMethod" href="#ConstrainedRootSolvers.NewtonBisectionMethod"><code>ConstrainedRootSolvers.NewtonBisectionMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Newton&#39;s method constrained by mininum and maximum ranges for 1D root solver</p><pre><code class="language-julia hljs">mutable struct NewtonBisectionMethod{FT&lt;:AbstractFloat} &lt;: ConstrainedRootSolvers.AbstractCRSMethod{FT&lt;:AbstractFloat}</code></pre><p><strong>Fields</strong></p><ul><li><code>x_min::AbstractFloat</code></li></ul><p>: Lower bound</p><ul><li><code>x_max::AbstractFloat</code></li></ul><p>: Upper bound</p><ul><li><code>x_ini::AbstractFloat</code></li></ul><p>: Initial guess</p><ul><li><code>history::Vector</code></li></ul><p>: history of all simulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/method.jl#L81-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.NewtonRaphsonMethod" href="#ConstrainedRootSolvers.NewtonRaphsonMethod"><code>ConstrainedRootSolvers.NewtonRaphsonMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Newton raphson method for 1D root solver</p><pre><code class="language-julia hljs">mutable struct NewtonRaphsonMethod{FT&lt;:AbstractFloat} &lt;: ConstrainedRootSolvers.AbstractCRSMethod{FT&lt;:AbstractFloat}</code></pre><p><strong>Fields</strong></p><ul><li><code>x_ini::AbstractFloat</code></li></ul><p>: Initial guess</p><ul><li><code>history::Vector</code></li></ul><p>: history of all simulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/method.jl#L108-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.ReduceStepMethod" href="#ConstrainedRootSolvers.ReduceStepMethod"><code>ConstrainedRootSolvers.ReduceStepMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Reduce step method for 1D root solver. This method increases or decreases from     initial guess until no improvement is found. Then the incremantal step     decreases, and then the root solver continues.</p><pre><code class="language-julia hljs">mutable struct ReduceStepMethod{FT&lt;:AbstractFloat} &lt;: ConstrainedRootSolvers.AbstractCRSMethod{FT&lt;:AbstractFloat}</code></pre><p><strong>Fields</strong></p><ul><li><code>x_min::AbstractFloat</code></li></ul><p>: Lower bound</p><ul><li><code>x_max::AbstractFloat</code></li></ul><p>: Upper bound</p><ul><li><code>x_ini::AbstractFloat</code></li></ul><p>: Initial guess</p><ul><li><code>Δ_ini::AbstractFloat</code></li></ul><p>: Initial step</p><ul><li><code>history::Vector</code></li></ul><p>: history of all simulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/method.jl#L131-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.ReduceStepMethodND" href="#ConstrainedRootSolvers.ReduceStepMethodND"><code>ConstrainedRootSolvers.ReduceStepMethodND</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Reduce step method for 2D and above root solver. This method increases or     decreases each variable in the initial guess until no improvement is found.     Then the incremental steps decreases, and then the root solver continues.</p><pre><code class="language-julia hljs">mutable struct ReduceStepMethodND{FT&lt;:AbstractFloat} &lt;: ConstrainedRootSolvers.AbstractCRSMethod{FT&lt;:AbstractFloat}</code></pre><p><strong>Fields</strong></p><ul><li><code>x_mins::Vector{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: Lower bound</p><ul><li><code>x_maxs::Vector{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: Upper bound</p><ul><li><code>x_inis::Vector{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: Initial guess</p><ul><li><code>x_targ::Vector{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: Target x</p><ul><li><code>x_temp::Vector{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: Temporary x</p><ul><li><code>Δ_inis::Vector{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: Initial step</p><ul><li><code>Δ_oper::Vector{FT} where FT&lt;:AbstractFloat</code></li></ul><p>: Operation step</p><ul><li><code>Δjd::Vector{Bool}</code></li></ul><p>: Vector of judges</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/method.jl#L162-L173">source</a></section></article><h2 id="Tolerance-options"><a class="docs-heading-anchor" href="#Tolerance-options">Tolerance options</a><a id="Tolerance-options-1"></a><a class="docs-heading-anchor-permalink" href="#Tolerance-options" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.AbstractTolerance" href="#ConstrainedRootSolvers.AbstractTolerance"><code>ConstrainedRootSolvers.AbstractTolerance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract tolerance type</p><pre><code class="language-julia hljs">abstract type AbstractTolerance{FT}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/tolerance.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.ResidualTolerance" href="#ConstrainedRootSolvers.ResidualTolerance"><code>ConstrainedRootSolvers.ResidualTolerance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tolerance for target function residual</p><pre><code class="language-julia hljs">struct ResidualTolerance{FT} &lt;: ConstrainedRootSolvers.AbstractTolerance{FT}</code></pre><p><strong>Fields</strong></p><ul><li><code>tol::Any</code></li></ul><p>: Tolerance for residual</p><ul><li><code>n_limit::Int64</code></li></ul><p>: limit of iterations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/tolerance.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.SolutionTolerance" href="#ConstrainedRootSolvers.SolutionTolerance"><code>ConstrainedRootSolvers.SolutionTolerance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tolerance for solution</p><pre><code class="language-julia hljs">struct SolutionTolerance{FT} &lt;: ConstrainedRootSolvers.AbstractTolerance{FT}</code></pre><p><strong>Fields</strong></p><ul><li><code>tol::Any</code></li></ul><p>: Tolerance for solution</p><ul><li><code>n_limit::Int64</code></li></ul><p>: limit of iterations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/tolerance.jl#L37-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.SolutionToleranceND" href="#ConstrainedRootSolvers.SolutionToleranceND"><code>ConstrainedRootSolvers.SolutionToleranceND</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tolerance for 2D and above solution</p><pre><code class="language-julia hljs">struct SolutionToleranceND{FT} &lt;: ConstrainedRootSolvers.AbstractTolerance{FT}</code></pre><p><strong>Fields</strong></p><ul><li><code>tol::Vector</code></li></ul><p>: Tolerance for solution</p><ul><li><code>n_limit::Int64</code></li></ul><p>: limit of iterations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/tolerance.jl#L57-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.if_break" href="#ConstrainedRootSolvers.if_break"><code>ConstrainedRootSolvers.if_break</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Determine whether to stopping finding the solution depending on the tolerance     type.</p><pre><code class="language-julia hljs">if_break(tol, x1, x2, y, n)</code></pre><p>defined at <a href="https://github.com/Yujie-W/JuliaUtilities/tree/017271df0147a581d13485e2afb8d02684580703//packages/ConstrainedRootSolvers.jl/src/tolerance.jl#L118"><code>/home/runner/work/JuliaUtilities/JuliaUtilities/packages/ConstrainedRootSolvers.jl/src/tolerance.jl:118</code></a>.</p><pre><code class="language-julia hljs">if_break(tol, x1, x2, y, n)</code></pre><p>defined at <a href="https://github.com/Yujie-W/JuliaUtilities/tree/017271df0147a581d13485e2afb8d02684580703//packages/ConstrainedRootSolvers.jl/src/tolerance.jl#L148"><code>/home/runner/work/JuliaUtilities/JuliaUtilities/packages/ConstrainedRootSolvers.jl/src/tolerance.jl:148</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/tolerance.jl#L82-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstrainedRootSolvers.next_xy!" href="#ConstrainedRootSolvers.next_xy!"><code>ConstrainedRootSolvers.next_xy!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">next_xy!(f::Function,
         xy::Matrix{FT},
         history::Vector{Vector{FT}},
         stepping::Bool
) where {FT&lt;:AbstractFloat}</code></pre><p>Determine the next points to simulate, given</p><ul><li><code>f</code> Function to find peak</li><li><code>xy</code> Matrix of x (1st column) and y (2nd column)</li><li><code>history</code> A vector to save simulations</li><li><code>stepping</code> Optional. If true, save the optimization steps to the history   field in method struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Yujie-W/JuliaUtilities/blob/017271df0147a581d13485e2afb8d02684580703/packages/ConstrainedRootSolvers.jl/src/find_peak.jl#L7-L20">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../NetcdfIO/">NetcdfIO »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 11 November 2022 18:44">Friday 11 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
